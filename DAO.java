package libs.DAO;

import libs.DAO.decorators.*;
import libs.DAO.exceptions.*;
import libs.logger.Logger;
import org.springframework.dao.IncorrectResultSizeDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;

import javax.el.MethodNotFoundException;
import java.io.InvalidClassException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

public class DAO {
    protected final JdbcTemplate jdbcTemplate;

    public DAO(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }


    public void persist(Object object) throws WrongDeclarationException {
            SimpleJdbcInsert insert = new SimpleJdbcInsert(jdbcTemplate);
            insert.withTableName(getTableName(object.getClass()));
            Field idField = getIdField(object.getClass());
            Id id = idField.getAnnotation(Id.class);
        try {
            Map<String, ?> params = createParameters(object);
            insert.usingColumns(params.keySet().toArray(new String[0]));
            if (id.generated()) {
                insert.usingGeneratedKeyColumns(idField.getAnnotation(Column.class).name());
                Number key = insert.executeAndReturnKey(params);
                try {
                    Method method = findSetter(idField);
                    if(method!=null){
                        method.setAccessible(true);
                        method.invoke(object, getIdCastedValue(idField, key));
                    }
                    if(method==null){
                        idField.setAccessible(true);
                        idField.set(object, getIdCastedValue(idField, key));
                    }
                } catch (Exception e) {
                    throw new DAOMappingException("While mapping autogenerated key value got error (" + e.getMessage() + " - " + e.getMessage() + "). Got key value `" + key.intValue() + "` to field " + idField.getType() + " [" + idField.getDeclaringClass().getSimpleName() + "];");
                }
            }
            if (!id.generated()) {
                insert.execute(params);
            }
        }catch (IllegalAccessException ex){
            throw new DAOMappingException("Can't map object values to insert. Nested exception ["+ex.getClass().getSimpleName()+"] "+ex.getMessage());
        }
    }

    private Object getIdCastedValue(Field field, Number value) throws InvalidClassException {
        if(field.getType().equals(long.class) || field.getType().equals(Long.class)) return value.longValue();
        if(field.getType().equals(int.class) || field.getType().equals(Integer.class)) return value.intValue();
        if(field.getType().equals(byte.class) || field.getType().equals(Byte.class)) return value.byteValue();
        if(field.getType().equals(float.class) || field.getType().equals(Float.class)) return value.floatValue();
        if(field.getType().equals(double.class) || field.getType().equals(Double.class)) return value.doubleValue();
        if(field.getType().equals(short.class) || field.getType().equals(Short.class)) return value.shortValue();
        throw new InvalidClassException("Invalid class of generated key");
    }

    private String getTableName(Class object) throws InvalidTableNameException {
        Table table = (Table) object.getAnnotation(Table.class);
        if(table == null || table.name().isEmpty()) throw new InvalidTableNameException(object);
        return table.name();
    }

    private Field getIdField(Class object) throws InvalidColumnNameException, IdNotExistsException {
        for(Field field: object.getDeclaredFields()){
            Id id = field.getAnnotation(Id.class);
            if(id == null) continue;
            Column column = field.getAnnotation(Column.class);
            if(column == null || column.name().isEmpty()) throw new InvalidColumnNameException(field);
            return field;
        }
        throw new IdNotExistsException(object);
    }

    private Map<String, ?> createParameters(Object object) throws InvalidColumnNameException, IllegalAccessException {
        Map<String, Object> result = new HashMap<>();
        for(Field field: object.getClass().getDeclaredFields()){
            if(field.getAnnotation(IgnoreColumn.class)!=null) continue;
            Method getter = findGetter(field);
            Object value = null;
            if(getter!=null){
                getter.setAccessible(true);
                try {
                    value = getter.invoke(object);
                } catch (InvocationTargetException e) {
                    getter = null;
                }
            }
            if(getter==null){
                field.setAccessible(true);
                value = field.get(object);
            }
            if(field.getAnnotation(DefaultPersist.class)!=null && value == null) continue;
            Column column = field.getAnnotation(Column.class);
            Id id = field.getAnnotation(Id.class);
            if(id!=null && id.generated()) continue;
            if(column==null || column.name().isEmpty()) throw new InvalidColumnNameException(field);
            if(field.getType().isEnum()) value = ((Enum) value).ordinal();
            result.put(column.name(), value);
        }
        return result;
    }

    protected <T> RowMapper<T> getMapper(Class<T> mapperClass){
        return new CustomMapper<>(mapperClass);
    }

    protected class CustomMapper<T> implements RowMapper<T> {
        private final Class<T> tClass;

        private CustomMapper(Class<T> tClass) {
            this.tClass = tClass;
        }

        @Override
        public T mapRow(ResultSet rs, int rowNum) throws SQLException {
            try {
                T result = tClass.getDeclaredConstructor().newInstance();
                for(Field field: tClass.getDeclaredFields()){
                    Column column = field.getAnnotation(Column.class);
                    if(column == null || column.name().isEmpty()) continue;
                    Object value = null;
                    value = rs.getObject(column.name());
                    if(field.getType().isPrimitive() && value==null) continue;
                    if(field.getType().isEnum()){
                        if(value != null)
                            value = field.getType().getEnumConstants()[(int)value];
                    }
                    Method method = findSetter(field);
                    if(method!=null){
                        try {
                            method.setAccessible(true);
                            method.invoke(result, value);
                            continue;
                        } catch (InvocationTargetException e) {
                            Logger.log("Can't use "+method.getName()+" setter on object "+tClass+", trying to assign value to field");
                        }
                    }
                    field.setAccessible(true);
                    field.set(result, value);
                }
                return result;
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
                Logger.logException("While trying to map query result to object, got exception: ", e, true);
                return null;
            }
        }
    }

    /**
     *
     * @param <T>
     * @param sql SQL query to execute
     * @param neededClass
     * @param params
     * @return
     */
    protected <T> Optional<T> queryForOne(String sql, Class<T> neededClass, Object... params){
        List<T> elements = jdbcTemplate.query(sql, getMapper(neededClass), params);
        if(elements.size()==0) return Optional.empty();
        return Optional.of(elements.get(0));
    }

    protected <T> Optional<T> queryForOnePrimitive(String sql, Class<T> neededClass, Object... params){
        try{
            return Optional.ofNullable(jdbcTemplate.queryForObject(sql, neededClass, params));
        } catch (
            IncorrectResultSizeDataAccessException exception){
//            logger.logException("While retrieving data for query: "+sql+" got null", exception, false);
            return Optional.empty();
        }
    }

    private static Method findSetter(Field field) {
        try {
            return field.getDeclaringClass().getDeclaredMethod("set" + Character.toUpperCase(field.getName().charAt(0)) + field.getName().substring(1), field.getType());
        }catch (NoSuchMethodException e){
            return null;
        }
    }

    private static Method findGetter(Field field) {
        try {
            return field.getDeclaringClass().getDeclaredMethod("get" + Character.toUpperCase(field.getName().charAt(0)) + field.getName().substring(1));
        }catch (NoSuchMethodException e){
            return null;
        }
    }
}
